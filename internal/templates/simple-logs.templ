package templates

import (
	"fmt"
	"pippaothy/internal/logs"
	"strconv"
	"strings"
)

templ logEntryComponent(entry logs.LogEntry) {
	<div class={ "border border-base-200 rounded-lg p-4 border-l-2", getLevelColor(entry.Level) }>
		<div class="flex justify-between items-start mb-3">
			<div class="text-sm text-base-content/60">
				{ entry.Timestamp.Format("2006-01-02 15:04:05") }
				if entry.RequestID != "" {
					<span class="ml-2 text-xs text-base-content/50 font-mono">{ entry.RequestID }</span>
				}
			</div>
			<div class={ "badge badge-sm", getLevelBadge(entry.Level) }>
				{ entry.Level }
			</div>
		</div>
		
		<div class="text-base-content font-mono text-sm mb-2 leading-relaxed">
			{ entry.Message }
		</div>
		
		if entry.Method != "" && entry.Path != "" {
			<div class="text-xs text-base-content/60 bg-base-200 px-2 py-1 rounded inline-block">
				{ entry.Method } { entry.Path }
			</div>
		}
		
		if entry.ClientIP != "" {
			<div class="text-xs text-base-content/50 mt-2">
				{ entry.ClientIP }
			</div>
		}
	</div>
}

templ SimpleLogs(result logs.LogResult, query logs.LogQuery) {
	<div class="max-w-4xl mx-auto">
		<div class="mb-8">
			<h1 class="text-2xl font-medium mb-2">Application Logs</h1>
			<p class="text-base-content/60">Recent log entries from the application</p>
		</div>

		<!-- Filter Form -->
		<div class="bg-base-100 border border-base-200 rounded-lg p-4 mb-6">
			<form 
				hx-get="/logs" 
				hx-target="#log-container"
				hx-indicator="#loading"
			>
				<div class="flex gap-4 items-end flex-wrap">
					<div class="form-control min-w-24">
						<label class="label">
							<span class="label-text text-sm">Level</span>
						</label>
						<select name="level" value={ query.Level } class="select select-bordered select-sm">
							<option value="">All</option>
							<option value="debug">Debug</option>
							<option value="info">Info</option>
							<option value="warn">Warn</option>
							<option value="error">Error</option>
						</select>
					</div>
					<div class="form-control min-w-20">
						<label class="label">
							<span class="label-text text-sm">Show</span>
						</label>
						<select name="limit" value={ fmt.Sprintf("%d", result.Limit) } class="select select-bordered select-sm">
							<option value="25">25</option>
							<option value="50">50</option>
							<option value="100">100</option>
						</select>
					</div>
					<div class="form-control min-w-32">
						<label class="label">
							<span class="label-text text-sm">Group By</span>
						</label>
						<select name="groupBy" value={ query.GroupBy } class="select select-bordered select-sm">
							<option value="">None</option>
							<option value="date">Date</option>
							<option value="hour">Hour</option>
							<option value="ip">IP Address</option>
						</select>
					</div>
					<div>
						<button type="submit" class="btn btn-outline btn-sm">
							Filter
						</button>
					</div>
				</div>
			</form>
		</div>

		<!-- Loading indicator -->
		<div id="loading" class="htmx-indicator text-center py-8">
			<span class="loading loading-spinner loading-sm"></span>
			<span class="text-base-content/60 ml-2 text-sm">Loading...</span>
		</div>

		<!-- Log entries container -->
		<div id="log-container">
			@SimpleLogEntries(result)
		</div>
	</div>
}

templ SimpleLogEntries(result logs.LogResult) {
	if result.Error != "" {
		<div class="alert alert-error mb-4">
			<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
			<div>
				<div class="font-medium">Error loading logs</div>
				<div class="text-sm">{ result.Error }</div>
			</div>
		</div>
	} else if result.Groups != nil && len(result.Groups) > 0 {
		<!-- Grouped log entries -->
		<div class="space-y-6 mb-8">
			for groupKey, groupEntries := range result.Groups {
				<div class="border border-base-200 rounded-lg p-6">
					<div class="flex items-center gap-3 mb-4">
						<h3 class="text-lg font-medium">
							if groupKey == "No IP" || isIPAddress(groupKey) {
								IP: { groupKey }
							} else if isDateFormat(groupKey) {
								Date: { groupKey }
							} else if isHourFormat(groupKey) {
								Hour: { groupKey }
							} else {
								{ groupKey }
							}
						</h3>
						<div class="badge badge-outline badge-sm">{ fmt.Sprintf("%d", len(groupEntries)) }</div>
					</div>
					<div class="space-y-3">
						for _, entry := range groupEntries {
							@logEntryComponent(entry)
						}
					</div>
				</div>
			}
		</div>
	} else {
		<!-- Log entries -->
		<div class="space-y-3 mb-8">
			for _, entry := range result.Entries {
				@logEntryComponent(entry)
			}
		</div>

		<!-- Pagination -->
		<div class="flex justify-between items-center pt-4 border-t border-base-200">
			<button
				if result.Page <= 1 {
					disabled
				}
				hx-get={ fmt.Sprintf("/logs?page=%d&limit=%d", result.Page-1, result.Limit) }
				hx-target="#log-container"
				hx-indicator="#loading"
				class="btn btn-ghost btn-sm"
			>
				← Previous
			</button>
			
			<span class="text-base-content/60 text-sm">Page { fmt.Sprintf("%d", result.Page) }</span>
			
			<button
				if !result.HasMore {
					disabled
				}
				hx-get={ fmt.Sprintf("/logs?page=%d&limit=%d", result.Page+1, result.Limit) }
				hx-target="#log-container"
				hx-indicator="#loading"
				class="btn btn-ghost btn-sm"
			>
				Next →
			</button>
		</div>
	}
}

func getLevelColor(level string) string {
	switch level {
	case "error":
		return "border-error"
	case "warn":
		return "border-warning"
	case "info":
		return "border-info"
	case "debug":
		return "border-base-content/30"
	default:
		return "border-base-300"
	}
}

func getLevelBadge(level string) string {
	switch level {
	case "error":
		return "badge-error"
	case "warn":
		return "badge-warning"
	case "info":
		return "badge-info"
	case "debug":
		return "badge-neutral"
	default:
		return "badge-ghost"
	}
}

func isIPAddress(s string) bool {
	parts := strings.Split(s, ".")
	if len(parts) != 4 {
		return false
	}
	for _, part := range parts {
		if _, err := strconv.Atoi(part); err != nil {
			return false
		}
	}
	return true
}

func isDateFormat(s string) bool {
	return len(s) == 10 && s[4] == '-' && s[7] == '-'
}

func isHourFormat(s string) bool {
	return len(s) >= 13 && strings.Contains(s, "h")
}